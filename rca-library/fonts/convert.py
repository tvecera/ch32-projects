#!/usr/bin/env python3
"""
MIT License

Copyright (c) 2026 Tomas Vecera, tomas@vecera.dev

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in all
copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
SOFTWARE.

============================================================================
Font Converter for Text Mode Video Output
============================================================================

Converts standard 8x8 bitmap fonts to preprocessed format for text video
modes (VMODE 6, 7, 8). The output format packs 2 pixels per byte in nibbles
for efficient rendering in the IRQ handler.

Input format:
  - Standard 8x8 bitmap font in row-major order
  - Each byte = 8 pixels (1 bit per pixel, MSB = leftmost)
  - Total: 512 bytes for 64 chars, 1024 bytes for 128 chars

Output format:
  - 2 pixels per byte (high nibble = first pixel, low nibble = second)
  - Pixel value: 0x04 = white (GPIO bit 6 >> 4), 0x00 = black
  - 8 rows * char_count * 4 bytes per row = 2KB (64 chars) or 4KB (128 chars)

Memory layout (for 64-char font):
  - Row 0: chars 0-63, 4 bytes each = 256 bytes
  - Row 1: chars 0-63, 4 bytes each = 256 bytes
  - ...
  - Row 7: chars 0-63, 4 bytes each = 256 bytes
  - Total: 8 * 256 = 2048 bytes

Usage:
  python3 convert.py > output_font.c

  Or modify the 'font' array below with your font data and run:
  python3 convert.py

Example:
  # Convert and save to file
  python3 convert.py > text_mode_font_custom.c

  # Then include in your project and set FONT macro in config.h

============================================================================
"""

# 64-character 8x8 font data (512 bytes)
# Characters: space (0x20) to underscore (0x5F)
# Layout: 8 rows of 64 bytes each (row-major order)
font = [
    0x00, 0x18, 0x6c, 0x6c, 0x18, 0x60, 0x38, 0x18, 0x0c, 0x30, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02,
    0x3c, 0x18, 0x3c, 0x3c, 0x1c, 0x7e, 0x1c, 0x7e, 0x3c, 0x3c, 0x00, 0x00, 0x0c, 0x00, 0x60, 0x3c,
    0x3c, 0x18, 0x7c, 0x3c, 0x78, 0x7e, 0x7e, 0x3c, 0x66, 0x7e, 0x06, 0xc6, 0x60, 0xc6, 0xc6, 0x3c,
    0x7c, 0x3c, 0x7c, 0x3c, 0x7e, 0x66, 0x66, 0xc6, 0xc6, 0x66, 0x7e, 0x3c, 0xc0, 0x3c, 0x18, 0x00,
    0x00, 0x18, 0x6c, 0x6c, 0x7e, 0x66, 0x6c, 0x18, 0x18, 0x18, 0x6c, 0x18, 0x00, 0x00, 0x00, 0x06,
    0x66, 0x38, 0x66, 0x66, 0x3c, 0x60, 0x30, 0x06, 0x66, 0x66, 0x00, 0x00, 0x18, 0x00, 0x30, 0x66,
    0x66, 0x3c, 0x66, 0x66, 0x6c, 0x60, 0x60, 0x66, 0x66, 0x18, 0x06, 0xcc, 0x60, 0xee, 0xe6, 0x66,
    0x66, 0x66, 0x66, 0x66, 0x18, 0x66, 0x66, 0xc6, 0x6c, 0x66, 0x06, 0x30, 0x60, 0x0c, 0x3c, 0x00,
    0x00, 0x18, 0x6c, 0xfe, 0xd8, 0x0c, 0x38, 0x30, 0x30, 0x0c, 0x38, 0x18, 0x00, 0x00, 0x00, 0x0c,
    0x6e, 0x78, 0x06, 0x06, 0x6c, 0x7c, 0x60, 0x06, 0x66, 0x66, 0x18, 0x18, 0x30, 0x7e, 0x18, 0x06,
    0x66, 0x66, 0x66, 0x60, 0x66, 0x60, 0x60, 0x60, 0x66, 0x18, 0x06, 0xd8, 0x60, 0xfe, 0xf6, 0x66,
    0x66, 0x66, 0x66, 0x60, 0x18, 0x66, 0x66, 0xc6, 0x38, 0x66, 0x0c, 0x30, 0x30, 0x0c, 0x66, 0x00,
    0x00, 0x18, 0x00, 0x6c, 0x7c, 0x18, 0x76, 0x00, 0x30, 0x0c, 0xfe, 0x7e, 0x00, 0x7e, 0x00, 0x18,
    0x76, 0x18, 0x0c, 0x1c, 0xcc, 0x06, 0x7c, 0x0c, 0x3c, 0x3e, 0x18, 0x18, 0x60, 0x00, 0x0c, 0x0c,
    0x60, 0x66, 0x7c, 0x60, 0x66, 0x7c, 0x7c, 0x6e, 0x7e, 0x18, 0x06, 0xf0, 0x60, 0xd6, 0xde, 0x66,
    0x7c, 0x66, 0x7c, 0x3c, 0x18, 0x66, 0x66, 0xd6, 0x38, 0x3c, 0x18, 0x30, 0x18, 0x0c, 0x00, 0x00,
    0x00, 0x18, 0x00, 0xfe, 0x36, 0x30, 0xdc, 0x00, 0x30, 0x0c, 0x38, 0x18, 0x00, 0x00, 0x00, 0x30,
    0x66, 0x18, 0x38, 0x06, 0xfe, 0x06, 0x66, 0x18, 0x66, 0x06, 0x00, 0x00, 0x30, 0x7e, 0x18, 0x18,
    0x60, 0x7e, 0x66, 0x60, 0x66, 0x60, 0x60, 0x66, 0x66, 0x18, 0x06, 0xd8, 0x60, 0xc6, 0xce, 0x66,
    0x60, 0x66, 0x6c, 0x06, 0x18, 0x66, 0x66, 0xfe, 0x38, 0x18, 0x30, 0x30, 0x0c, 0x0c, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x6c, 0xfc, 0x66, 0xcc, 0x00, 0x18, 0x18, 0x6c, 0x18, 0x18, 0x00, 0x18, 0x60,
    0x66, 0x18, 0x60, 0x66, 0x0c, 0x66, 0x66, 0x18, 0x66, 0x0c, 0x18, 0x18, 0x18, 0x00, 0x30, 0x00,
    0x66, 0x66, 0x66, 0x66, 0x6c, 0x60, 0x60, 0x66, 0x66, 0x18, 0x66, 0xcc, 0x60, 0xc6, 0xc6, 0x66,
    0x60, 0x6c, 0x66, 0x66, 0x18, 0x66, 0x3c, 0xee, 0x6c, 0x18, 0x60, 0x30, 0x06, 0x0c, 0x00, 0x00,
    0x00, 0x18, 0x00, 0x6c, 0x30, 0x06, 0x76, 0x00, 0x0c, 0x30, 0x00, 0x00, 0x18, 0x00, 0x18, 0xc0,
    0x3c, 0x7e, 0x7e, 0x3c, 0x0c, 0x3c, 0x3c, 0x18, 0x3c, 0x38, 0x18, 0x18, 0x0c, 0x00, 0x60, 0x18,
    0x3c, 0x66, 0x7c, 0x3c, 0x78, 0x7e, 0x60, 0x3c, 0x66, 0x7e, 0x3c, 0xc6, 0x7e, 0xc6, 0xc6, 0x3c,
    0x60, 0x36, 0x66, 0x3c, 0x18, 0x3c, 0x18, 0xc6, 0xc6, 0x18, 0x7e, 0x3c, 0x02, 0x3c, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x30, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x30, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xfe
]

# ============================================================================
# Configuration
# ============================================================================

# Pixel intensity value for "white" pixels
# 0x04 = bit 2 set, which becomes GPIO bit 6 when shifted left by 4 in nibble
# This matches the SendCharBitBangTextMode() assembly in rca.c
PIXEL_WHITE = 0x04
PIXEL_BLACK = 0x00

# ============================================================================
# Step 1: Expand font bytes to individual pixels
# ============================================================================
# Each input byte (8 pixels) becomes 8 output bytes (1 pixel each)
# Pixel values: PIXEL_WHITE (0x04) or PIXEL_BLACK (0x00)

pixels = []
for byte in font:
    # Process bits from MSB to LSB (left to right on screen)
    for i in range(7, -1, -1):
        bit = (byte >> i) & 1
        pixel = PIXEL_WHITE if bit else PIXEL_BLACK
        pixels.append(pixel)

# ============================================================================
# Step 2: Pack 2 pixels per byte (nibble format)
# ============================================================================
# High nibble = first pixel (left), low nibble = second pixel (right)
# This format allows fast extraction in IRQ handler:
#   srli a2, t0, 4    ; extract high nibble
#   andi a2, t0, 0x0f ; extract low nibble

packed_font = []
for i in range(0, len(pixels), 2):
    pixel_left = pixels[i]      # First pixel -> high nibble
    pixel_right = pixels[i + 1]  # Second pixel -> low nibble
    packed_byte = (pixel_left << 4) | pixel_right
    packed_font.append(packed_byte)

# ============================================================================
# Step 3: Output as C array
# ============================================================================

char_count = len(font) // 8  # 8 bytes per character row in input
output_size = len(packed_font)

print(f"// Font converter output")
print(f"// Input: {len(font)} bytes ({char_count} characters, 8x8 pixels)")
print(f"// Output: {output_size} bytes (2 pixels per byte, nibble format)")
print(f"//")
print(f"// Memory layout: {char_count} chars * 8 rows * 4 bytes = {output_size} bytes")
print(f"// Access pattern: font_data[char_index * 4 + row * {char_count} * 4]")
print()

# Generate array name based on character count
array_name = f"TextModeFont_{output_size}"
print(f"const unsigned char {array_name}[{output_size}] __attribute__((aligned(4))) = {{")

# Print 16 bytes per line for readability
for i in range(0, len(packed_font), 16):
    line = packed_font[i:i + 16]
    hex_values = ", ".join(f"0x{val:02X}" for val in line)
    comma = "," if i + 16 < len(packed_font) else ""
    print(f"    {hex_values}{comma}")

print("};")

# ============================================================================
# Print font descriptor template
# ============================================================================
print()
print("// Font descriptor for use with text modes:")
print(f"// const font_desc_t MyFont = {{")
print(f"//     .data = {array_name},")
print(f"//     .ascii_map = ascii_map_standard64,  // or NULL for 128-char fonts")
print(f"//     .char_count = {char_count},")
print(f"//     .space_idx = 0")
print(f"// }};")